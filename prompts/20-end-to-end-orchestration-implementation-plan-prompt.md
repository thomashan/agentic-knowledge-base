**Title:** Implementation Plan for End-to-End Orchestration and Runner

**Persona:** You are Gemini, an expert TDD Software Engineer.

**Context:** All the individual agent packages (`planner`, `research`, `intelligence`, `knowledge`, and `retrieval`) are now complete. The next critical step is to orchestrate these agents to work together to fulfill a
user's request. We will use `crewai` as the orchestration framework.

**Goal:** Create a comprehensive, test-driven implementation plan for the `agents-orchestrator-crewai` package and a `runner` package to execute the entire workflow.

**Deliverable:**
A single markdown file containing the complete implementation plan.

**Acceptance Criteria for the Plan:**

1. **Goal and Vision:** The plan must define the `CrewAIOrchestrator` as the central orchestrator that manages a crew of specialized agents. The `Runner` will be the entry point that kicks off the process. The overall goal is
   to take a user's query and produce a comprehensive answer by leveraging the combined capabilities of all agents.

2. **Core Components and Data Models:**
    * **`agents-orchestrator-crewai`:**
        * `CrewAIOrchestrator`: The main class that will define the crew (agents and tasks) and manage the execution flow.
        * `WorkflowConfig`: A Pydantic model to configure the crew, including defining the agents and the sequence of tasks.
    * **`runner`:**
        * `Runner`: A simple class or function that will instantiate the `CrewAIOrchestrator` and all the necessary agents and tools, and then start the crew's execution.
    * **Input/Output:**
        * **Input:** A simple user query (string).
        * **Output:** A final, consolidated answer (string) generated by the crew.

3. **High-Level Workflow:** The plan must detail the end-to-end workflow:
    1. The `Runner` receives the user query.
    2. The `Runner` initializes the `LLM`, all required tools (`QdrantTool`, `SearxNGSearchTool`, etc.), and all agents (`PlannerAgent`, `ResearchAgent`, etc.).
    3. The `Runner` uses a `WorkflowConfig` to define the agents and tasks for the `crewai` framework.
    4. The `Runner` instantiates the `CrewAIOrchestrator` with the configured crew.
    5. The `Runner` invokes the `CrewAIOrchestrator` with the user query.
    6. The `CrewAIOrchestrator` (leveraging `crewai`'s capabilities) executes the defined tasks in sequence, passing context between agents.
        * **PlannerAgent:** Creates the initial plan.
        * **ResearchAgent:** Gathers external information.
        * **IntelligenceAgent:** Analyzes and synthesizes information.
        * **KnowledgeAgent:** Persists key findings.
        * **RetrievalAgent:** Fetches information from the knowledge base when needed.
    7. After the crew finishes its work, the `CrewAIOrchestrator` returns the final result.
    8. The `Runner` outputs the final answer to the user.

4. **TDD Implementation Cycle:** The plan must detail a RED-GREEN-REFACTOR cycle for the new packages.
    * **`agents-orchestrator-crewai` package:**
        * Test File: `test_adapter.py`
        * **Unit Tests:**
            * Test the `CrewAIOrchestrator`'s ability to be instantiated.
            * Use **mock agents** and **mock tools** to verify that the `CrewAIOrchestrator` correctly initializes the `crewai` `Crew` object based on a `WorkflowConfig`.
            * Test the `run` method with mocks to ensure it calls the underlying `crew.kickoff()` method.
    * **`runner` package:**
        * **Test File:** `test_runner_integration.py`
        * **Integration Test:**
            * This will be a more comprehensive test that approaches an end-to-end scenario.
            * Instantiate **real agent classes** (`PlannerAgent`, `ResearchAgent`, etc.).
            * Use a **mock LLM** to control the outputs of the agents.
            * Use **mock tools** (`MockQdrantTool`, `MockSearxNGSearchTool`) to isolate the test from external services.
            * Create a test that simulates a user query and verifies that the `Runner` can orchestrate the agents to produce an expected (mocked) final output. This test will validate the flow of information between the
              agents as managed by the `crewai` orchestrator.

5. **Project Conventions:** The plan must adhere to all existing project conventions (dependency injection, use of abstract base classes where appropriate, etc.).

6. **Output File:** The final plan must be written to the file: `prompts/gemini-cli/20-end-to-end-orchestraction-implementation-plan.md`.
